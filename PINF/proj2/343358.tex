\documentclass[a4paper,12pt]{article}

\usepackage[margin=2.5cm]{geometry}
\usepackage[polish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{listings}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}

\usepackage{caption}

\tikzstyle{state} = [circle, minimum width=1.2cm, text centered, draw=black]
\tikzstyle{start} = [circle, minimum width=1.2cm, text centered, draw=red]
\tikzstyle{end} = [circle, minimum width=1.2cm, text centered, draw=blue]
\tikzstyle{arrow} = [thick,<->,>=stealth]

\begin{document}

\begin{table}
\resizebox{\columnwidth}{!}{
\begin{tabular}{|ll|l|}
\hline
\multicolumn{2}{|l|}{Sprawozdanie}                          & \begin{tabular}[c]{@{}l@{}}\small{Data wykonania}:\\ \today \end{tabular} \\ \hline
\multicolumn{1}{|l|}{Tytuł Mini-Projektu} & Wykonał         & Sprawdził                                                           \\ \hline
\multicolumn{1}{|l|}{Automat skończony}   & Monika Musielik & dr. inż. Konrad Markowski                                           \\ \hline
\end{tabular}
}
\end{table}

\tableofcontents

\section{Cel projektu}

Celem projektu było stworzenie symulacji automatu skończonego $M=(Q, \Sigma, \delta, q_{0}, F)$ o podanych symbolach wejściowych $\Sigma$, funkcji przejścia $\delta$, stanem początkowym $q_0$ oraz końowym $F$.

W specyfikacji programu należało narysować diagram z pokazanymi przejściami z zaznaczonym aktualnym stanem automatu.

\section{Rozwiązanie problemu}

Pierwszym krokiem aby stworzyć symulacje jest wizualizacja automatu skończonego w formie grafu, który ma na celu pomóc mi zrozumieć jak działa dany automat. Stan początkowy oznaczam czerwonym okręgiem, a stan końcowy oznaczam niebieskim okręgiem.

\begin{figure}[H]
    \begin{center}
        \begin{tikzpicture}[node distance=3cm]
        
        \node (q0) [state] {0};
        \node (q1) [start, below of=q0] {1};
        \node (q2) [state, right of=q0] {2};
        \node (q3) [end, below of=q2] {3};
    
        \draw [arrow] (q0) -- node[anchor=east] {1} (q1);
        \draw [arrow] (q2) -- node[anchor=west] {1} (q3);
    
        \draw [arrow] (q0) -- node[anchor=south] {0} (q2);
        \draw [arrow] (q1) -- node[anchor=north] {0} (q3);
        
        \end{tikzpicture}
    \end{center}
    \caption{Graf automatu skończonego}
\end{figure}

Wizualizacja maszyny (Rysunek 1) ma formę przypominającą kwadrat, gdzie każde przejście jest obustronne, dlatego pozwoliłam sobie na użycie strzałek obustronnych w celu uproszczenia rysunku. Inaczej mówiąc, jeżeli do tego automatu wpisze się 2 tą samą instrukcję, to stan automatu pozostanie taki sam.

\section{Szczegóły implementacyjne}

Program, zgodnie z poleceniem prowadzącego, należało zaimplementować w C/C++. Wybrałam do tego język C ze względu na niską złożoność problemu i brak wymogu używania programowania objektowego.

\subsection{Algorytm automatu skończonego}

Pierwszym krokiem w implementacji maszyny jest napisanie algorytmu funkcji przejścia $\delta$, która przyjmuje 2 argumenty: symbol $a \in \Sigma$ oraz instrukcję $b \in Q$.

\begin{lstlisting}[language=C]
int process_instruction(int instruction, int pivot) {
    switch (pivot) {
                               // if 1 / 0
        case 0: return instruction ? 1 : 2;
        case 1: return instruction ? 0 : 3;
        case 2: return instruction ? 3 : 0;
        case 3: return instruction ? 2 : 1;
        default: return -1;
    }
}
\end{lstlisting}

w tym przypadku \texttt{instruction} odpowiada instrukcji $b$, a \texttt{pivot} odpowiada symbolowi $a$. Funkcja \texttt{process\_instruction} przechodzi do odpowiedniego symbolu $b \in Q$ używając instrukcji wielokrotnego wyboru i następnie zwraca odpowiednią wartość $a \in \Sigma$ zgodnie z operatorem warunkowym. W celu zabezpieczenia funkcji przed symbolami z poza zbioru $Q$, w przypdku domyślnym zwraca zawsze $-1$.

\subsection{Metoda wprowadzania danych}

Następnie należy wybrać metodę wprowadzania danych przez użytkownika i napisać funkcje która je przetwarza do formatu przyjaznego przetwarzaniu. Postanowiłam dać użytkownikowi wybór między dodawaniem ciągu znaków $c \in \{0; 1\}$ jako argument w konsoli, a wprowadzaniem ich na bierząco w przypadku braku podania ich jako argument.

\begin{lstlisting}[language=C]
void render_plane(int instruction, int pivot);

int main(int argc, char* argv[]) {

    int pivot = START;
    render_plane(-1, pivot);

    if (argc < 2) {
        char c;
        ...
    } else {
        char* input = argv[1];
        ...
\end{lstlisting}

Na początku z predefiniowanych zmiennych na etapie preprocesora ustawia się początkowy stan automatu, następnie sprawdza ilość podanych argumentów w konsoli i wybiera odpowiadającą formę wprowadzania danych. Jeżeli użytkownik nie podał instrukcji jako argument, program będzie o nie prosił w konsoli.

Powstała dodatkowo funkcja \texttt{render\_plane} odpowiadająca za rysowanie diagramu automatu, którego kodu pozwalam sobie nie umieszczać w tym sprawozdaniu ze względu na jej kształt przypominający \emph{spaghetti}.

\subsubsection{Wprowadzanie danych w konsoli}

Wprowadzanie danych za pośrednictwem konsoli jest zaimplementowane poprzez pętle \texttt{while} oraz funkcje \texttt{scanf}. Bez żadnych modyfikacji, pętla działałaby bez końca, dlatego został dodany warunek przerwania pętli poprzez wprowadzenie znaku \texttt{e}. 

\begin{lstlisting}[language=C]
char c;
while( scanf("%c", &c) && c != 'e' ) {

    if (c != '0' && c != '1') {
        if (c != '\n')
            printf("Wykryto niewlasciwa instrukcje! (%c)\n", c);
        continue;
    }

    int instruction = c == '0' ? 0 : 1;
    pivot = process_instruction(instruction, pivot);

    render_plane(instruction, pivot);
    ...
}
\end{lstlisting}

Ten fragment kodu jest wykonywny w wypadku braku podania instrukcji jako argument. Program wchodzi w pętlę proszenia użytkownika o znak, którą można przerwać podając klawisz \texttt{e}. Można również użyć kombinacji \texttt{\^{}C}, ale wtedy program nie pokaże wyników końcowych jak informacji o zaakceptowaniu ciągu.

Dalej program przypisuje wartość typu \texttt{int} dla danej instrukcji, przez wcześniejsze sprawdzanie zgodności formatu i specyfike zadania, która zakłada tylko 2 rodzaje instrukcji, można użyć prostej instrukcji warunkowej która zamieni \texttt{'0'} na $0$, i \texttt{'1'} na $1$ w bardzizej efektywny sposób niż np. funkcja \texttt{atoi}.

Na końcu program przechodzi do następnej instrukcji używając \texttt{process\_instruction} i rysuje zaktualizowaną planszę (graf).

Dodatkowo można zauważyć ochronę programu przed \emph{faux pas} użytkownika na znaki niezawierające się w zbiorze $c \in \{0,1,e\}$. Jeśli użytkownik poda więcej niż jedną instruckje w linii, program wykona je po kolei.

\subsubsection{Wprowadzanie danych jako argument}

Wprowadzanie danych jako argument dostępny w \texttt{argv[1]} jest nieco bardziej skomplikowane, ale działa na podobnej zasadzie.Program zakłada tablicę znaków, preferowalnie należących do zbioru $c \in \{0,1\}$, które będą służyć jako instrukcje.

Program został wzbogacony o funkcje \texttt{scanf("\%c")}, która zwiększa doświadczenie użytkownika i zatrzymuje symulacje automatu co każdy krok dla wygodniejszej analizy przez użytkownika.

\begin{lstlisting}[language=C]
char* input = argv[1];
int n = strlen(input);

for (int i = 0; i < n ; i++) {
    scanf("%c");
    if (input[i] != '0' && input[i] != '1') {
        ...
        continue;
    }

    int instruction = input[i] == '0' ? 0 : 1;
    pivot = process_instruction(instruction, pivot);
    ...
}
\end{lstlisting}

Analogicznie do wycinka kodu w (3.2.1), program iteruje przez każdą instrukcje maszyny, ale tym razem w pętli \texttt{for}, iterując po indeksie tablicy znaków \texttt{input} przez interator. Następnie sprawdza poprawność znaku, czy należy do $c$. W przeciwnym wypadku zwraca stosowny komunikat i ignoruje tą iterację przez instrukcje \texttt{continue}.

Następnie identycznie do poprzedniego przypdaku program przypisuje liczbę całkowitą do \texttt{instruction}, przechodzi do kolejnej instrukcji i rysuje zaktualizowaną planszę (graf).

\subsection{Pokazywanie wyników końcowych}

Specyfikacja nakazuje podanie komunikatu o zaakceptowaniu ciągu, natomiast przez stukturę kodu w poprzednich etapach, wyświetlanie wyniku końcowego można zaimplementować prostą instrukcją warunkową.

\begin{lstlisting}[language=C]
if (pivot == END) {
    printf("Gratulujemy! Ciag zostal zaakceptowany.\n");
}

return 0;
\end{lstlisting}

Na poziomie preprocesora podobnie jak w przypadku zmiennej \texttt{START}, zmienna \texttt{END} jest zdefiniowana przez makro \texttt{\#define}. 

W obecnej budowie programu na koniec powinna zostać wyświetlona użytkownikowi plansza końcowa oraz komunikat o akceptacji ciągu jeśli zostały spełnione potrzebne warunki. 

\section{Sposób wywołania programu}

Program jest napisany zgodnie od \texttt{ISO C99}, więc zwykła kompilacja używając dowolnego kompilatora C powinna wystarczyć. Program został napisany tak, aby nie potrzebował żadnych dodatkowych plików, a używa tylko bibliotek \texttt{string} oraz \texttt{stdio}. Można go skompilować w następujący sposób używając popularnych kompilatorów:

\begin{lstlisting}[language=bash]
cc 343358.c
gcc 343358.c
g++ 343358.c
\end{lstlisting}

Następnie można go uruchomić na 2 sposoby, podając argumenty przy wywoływaniu programu lub podając je później w programie.

\begin{lstlisting}[language=bash]
./a.out 0011001
./a.out
\end{lstlisting}

Program został uodporniony na działania użytkownika wbrew założeniom twórcy, jeśli użytkownik poda nieznany znak, to program go zignoruje, wyświetalając odpowiedni komunikat, jeśli jest stosowny.

%Niestety program nie jest odporny na braki prądu, pożar, trzęsienie ziemi, korupcje dysku, wadliwy kompilator, korupcje kodu w trakcie pobierania, przekręcanie bitów spowodowane promieniowaniem kosmicznym lub anihilacje rasy ludzkiej np. przez rozpoczęcie Trzeciego Uderzenia.

\section{Wnioski i spostrzeżenia}

Pierwotnie program miał być okienkowy za pomocą biblioteki \texttt{raylib}, jednak ze względu na znaczące utrudnienie kompilowania programu na innych komputerach, w szczególności na systemie operacyjnym Windows z tego pomysłu szybko zrezygnowałam.

Sam sczkic programu, działający \emph{aby działał}, powstał jeszcze podczas zajęć. Natomiast najwięcej czasu spędziłam na implementacji graficznej programu. Ze względu na jej monotoniczność i brak \emph{nagrody} z napisania dedykowanego systemu rysowania grafów, napisałam brzydką funkcję która jest bardzo trudna do rozszerzenia, lecz spełnia wymogi tego konkretnego przypadku zadania.
\end{document}
